##Java虚拟机

###Java技术体系
包括几个部分：Java程序设计语言，各种硬件平台上的Java虚拟机，Class文件格式，Java API类库，第三方Java类库。
其中（Java程序设计语言，Java虚拟机，Java API类库）合称之为JDK（Java Development Kit），JDK是支持Java程序开发的最小环境。
（Java API类库中的java SE api子集，java虚拟机）合称为JRE（Java Runtime Environment），JRE是支持java程序运行的标准环境。

###自动内存管理机制
####Java内存区域和内存溢出异常
#####1.运行时数据区域：程序计数器，虚拟机栈，本地方法栈，Java堆，方法区，
- 1.1程序计数器:一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。
字节码解释器的工作就是通过改变该值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。<font color=red size=5>线程私有</font>
- 1.2Java虚拟机栈：虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时
都会创建一个栈帧用于存储局部变量表、 操作数栈、 动态链接、 方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。局部变量表中存储了各种基本数据类型，对象引用，和return address类型。<font color=red size=5>线程私有,生命周期与线程同步</font>
- 1.3本地方法栈：和虚拟机栈十分相似，区别是虚拟机栈执行Java服务，本地方法栈执行Native方法服务。
- 1.4Java堆：虚拟机启动时创建，存放对象实例，<font color=red size=5>堆是所占内存最大，所有线程共享。</font>
- 1.5方法区：存储已被虚拟机加载的类信息、常量、静态常量、即时编译器编译后的代码等数据。<font color=red size=5>所有线程共享。</font>
- 运行时常量池：是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。

#####2.HotSpot虚拟机对象探秘：
- 2.1对象的创建:  
虚拟机遇到一条new指令时，**首先**将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、 解析和初始化过。 如果没有，那必须先执行相应的类加载过程，**在类加载检查通过后接下来虚拟机将为新生对象分配内存。**，对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把
一块确定大小的内存从Java堆中划分出来。 

> 假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump the Pointer）。


>如果Java堆中的内存并不是规整的，已使用的内存和空
闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记
录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，
并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。 


>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内
存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）。 哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。

**内存分配完成后，**虚拟机需要将分配到的内存空间都初始化为零值;**接下来，虚拟机要对对象进行必要的设置，**例如这个对象是哪个类的实例、 如何才能找
到类的元数据信息、 对象的哈希码、 对象的GC分代年龄等信息。 这些信息存放在对象的对
象头（Object Header）之中。 执行new指令之后会接着;
**执行＜init＞方法，**把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完
全产生出来。
- 2.2对象的内存布局：

> 对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

**对象头包含内容**:第一部分，存储对象自身运行时数据，如哈希码（HashCode）、 GC分代年龄、 锁状态标志、 线程持有的锁、 偏向线程ID、 偏向时间戳等；
第二部分，类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。  
**实例数据部分**是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。  
**对齐填充**并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。 满足8的整数倍
- 2.3对象的访问定位：
 对象访问方式也是取决于虚拟机实现而定的。 目前主流的访问方式有使用**句柄和直接指针**两种。  
如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中
存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信
息  
如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的
相关信息，而reference中存储的直接就是对象地址。


#####3.OutOfMemoryError异常：
- 3.1Java堆溢出：Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生
内存溢出异常。   
解决该问题需要确认是发生了内存泄露还是内存溢出，通过内存映像工具对Dump出来的堆转储快照分析。若是内存泄露，找到泄露对象和GC Roots的引用链，进而判断出泄露代码的位置。如果是内存溢出，则通过调控对象的虚拟机堆参数，以及检查某些对象是否生命周期过长，持有状态时间过长等情况去尝试减少内存消耗。

- 3.2拟机栈和本地方法栈溢出：如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。
单线程测试时只会出现Stack Overflow异常，在多线程测试时会出现OutOfMemoryError异常，
虚拟机内存=java堆内存+方法区内存+虚拟机栈内存总内存（线程数量×每个线程所占栈内存），因此若出现因线程过多导致的内存溢出，可考虑从减少堆内存和方法区内存的方式，解决问题。

- 3.3方法区和运行时常量池溢出：这种内存溢出比较常见，遇到这种情况时要注意类的回收情况。

####垃圾收集器与内存分配策略
#####1.概述：哪些内存需要回收，什么时候回收，怎么回收。
- 1.1哪些内存需要回收：
**程序计数器，虚拟机栈，本地方法栈**三个区域随线程而生，当线程或者方法结束了，自动释放内存，因此这几个区域的内存分配和回收都具有确定性，因此不需要考虑回收问题。而**java堆和方法区**则不一样。一个接口中多个实现类需要的内存不一样，一个方法中多个分支需要的内存也不一样，这些都是动态的，gc关注的就是这一部分的内存。

#####2.对象死了么
- 2.1引用计数算法（Reference Counting）：

> 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。

主流java虚拟机都没有应用这种方法，因为它无法解决对象相互循环引用的问题。

- 2.2可达性分析算法（Reachability Analysis）：

> 算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。由此会被判为可回收对象。 

在Java语言中，可作为**GC Roots的对象**包括下面几种：  
虚拟机栈（栈帧中的本地变量表）中引用的对象。  
方法区中类静态属性引用的对象。  
方法区中常量引用的对象。  
本地方法栈中JNI（即一般说的Native方法）引用的对象。

- 2.3再谈引用：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、 虚引用（PhantomReference）
`
如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块
内存代表着一个引用。
`
**强引用**：指在程序代码之中普遍存在的，类似“Object obj=new Object（）”这类的引
用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。  
**软引用**:描述一些还有用但并非必需的对象。 对于软引用关联着的对象，在系统将
要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。 如果这次回
收还没有足够的内存，才会抛出内存溢出异常。  
**弱引用**：描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的
对象只能生存到下一次垃圾收集发生之前。 当垃圾收集器工作时，无论当前内存是否足够，
都会回收掉只被弱引用关联的对象。  
**虚引用**：最弱的一种引用关系。 一个对象是否有虚引
用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。 为一
个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

- 2.4生存还是死亡：可达性算法中不可达的对象也不是立即死，他会经过两次标记过程，对象不可达会被第一次标记并且进行一次筛选，筛选的条件是对象是否有必要执行finalize（）方法，若没覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。  
若有必要执行inalize（）方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、 低优先级的Finalizer线程去执行它。在稍后gc会二次标记，随后回收 

- 2.5回收方法区：也称永久代垃圾回收包括两部分：废弃常量和无用的类。  
废弃常量回收和堆回收类似，类需要同时满足下面3个条件才能算是“无用的类”：  
1.该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。  
2.加载该类的ClassLoader已经被回收。  
3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该
类的方法。


#####3.垃圾回收算法：
- 3.1标记-清除算法（Mark-Sweep）：  最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：  
首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象；  
该算法有两点不足的地方：**一个是效率问题，**标记和清除两个过程的效率都不高； 
**另一个是空间问题**，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程
序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

- 3.2复制算法（Copying）：**回收新生代，为解决效率问题**，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。 当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点.  
现在有一种更优解的方法，将内存分为8：1：1的分配分为eden和两块survivor空间。每次使用时只会eden和一块survivor空间，回收时将这两块空间上存活的对象一次性的复制到另一个survivor上，然后清理掉另外两块空间，

- 3.3标记-整理算法（Mark-Compact）：**针对老年代特点，当对象存活率较高的时候。**标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

- 3.4分代收集算法（Generational Collection）：只是根据对象存活周期的不同将内存划分为几块。 一般是把Java堆分为**新生代和老年代**，这样就可以根据各个年代的特点采用最适当的收集算法。 **在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法**，只需要付出少量存活对象的复制成本就可以完成收集。 **而老年代中因为对象存活率高、 没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。**



#####4.HotSpot的算法实现
- 4.1枚举根节点：目前的主流Java虚拟机使用的都是准确式GC，所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。 在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的
时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定位置记录下栈和寄存器中哪些位置是引用。 这样，GC在扫描时就可以直接得知这些信息了。 

- 4.2安全点：只是在“特定的
位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都
能停顿下来开始GC，只有在到达安全点时才能暂停。 Safepoint的选定既不能太少以致于让
GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。 所以，安全点的选定基
本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行
的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间
执行”的最明显特征就是指令序列复用，例如方法调用、 循环跳转、 异常跳转等，所以具有
这些功能的指令才会产生Safepoint。

- 4.3安全区域：安全区域是指在一段代码片段之中，引用关系不会发生变化。 在这个区域中的任意地方开始GC都是安全的。 我们也可以把Safe Region看做是被扩展了的Safepoint。


#####5.垃圾收集器
如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。
新生代垃圾回收器:Serial、ParNew、 Parallel Scavenge、 G1
老生代垃圾回收器：CMS、 Serial Old、 Parallel Old

- 5.1:Serial收集器: Serial收集器是最基本、 发展历史最悠久的收集器，曾经（在JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。 **这是一个单线程的收集器**，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。  
他的工作流程是：**首先多个线程都达到安全点，然后GC线程启动，新生代启用复制算法，老生代采用标记-整理算法，同时暂停所有用户线程，离开安全点，GC线程结束，用户线程启动。**

- 5.2ParNew收集器：其实就是Serial收集器的**多线程版本**，除了使用多条线程进行垃圾收集之
外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX：SurvivorRatio、 -XX：
PretenureSizeThreshold、 -XX：HandlePromotionFailure等）、 收集算法、 Stop The World、 对象分配规则、 回收策略等都与Serial收集器完全一样，

		并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
		并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。

- 5.3Parallel Scavenge收集器:Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。

- 5.4Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整
理”算法。 

- 5.5Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。

- 5.6CMS收集器:CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。 目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。 CMS收集器就非常符合这类应用的需求。  
基于“标记—清除”算法实现的，分为四个步骤：  
初始标记（CMS initial mark）  
并发标记（CMS concurrent mark）  
重新标记（CMS remark）  
并发清除（CMS concurrent sweep）  
其中，初始标记、 重新标记这两个步骤仍然需要“Stop The World”。 **初始标记**仅仅只是
标记一下GC Roots能直接关联到的对象，速度很快，**并发标记阶段**就是进行GC RootsTracing
的过程，而**重新标记阶段**则是为了修正并发标记期间因用户程序继续运作而导致标记产生变
动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远
比并发标记的时间短。  
由于整个过程中**耗时最长的并发标记和并发清除过程**收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。  

- 5.7G1收集器：G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一；G1是一款面向服务端应用的垃圾收集器。与其他GC收集器相比，G1具备如下特点：  
1.**并行与并发**：G1能充分利用多CPU、 多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。  
2.**分代收集**：与其他收集器一样，分代概念在G1中依然得以保留。 虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、 熬过多次GC的旧对象以获取更好的收集效果。  
3.空间整合：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。 这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。  
4.可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。  
5.在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这
样。 使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分
为多个大小相等的独立区域（Region），G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的
空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时
间，优先回收价值最大的Region  

- G1收集器的运作大致可划分为以下几个步骤：
初始标记（Initial Marking）
并发标记（Concurrent Marking）
最终标记（Final Marking）
筛选回收（Live Data Counting and Evacuation）；与CMS不同的是，在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。

#####6.内存分配与回收策略
**堆大小 = 新生代 + 老年代。默认下，新生代 ( Young ) = 1/3 的堆空间大小，老年代 ( Old ) = 2/3 的堆空间大小**
自动内存管理可归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。  
对象的内存分配就是在堆上分配对象主要分配在新生代的Eden区上，少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟
机中与内存相关的参数的设置。 

- 对象优先在Eden分配：大多数情况下，对象在新生代Eden区中分配。 当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。
 
		新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。

		老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC Major GC的速度一般会比Minor GC慢10倍以上。

- 大对象直接进入老年代:所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组

- 长期存活的对象将进入老年代:虚拟机给每个对象定义了一个对象年龄（Age）计数器。 如果对象Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。 对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。 对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置

- 动态对象年龄判定:为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

- 空间分配担保:在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有
对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。 如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。

####虚拟机性能监控与故障处理工具
给一个系统定位问题的时候，知识、 经验是关键基础，数据是依据，工具是运用知识处理数据的手段。 这里说的数据包括：运行日志、 异常堆栈、 GC日志、 线程快照（threaddump/javacore文件）、 堆转储快照（heapdump/hprof文件）等。

- jps：虚拟机进程状况工具
- jstat：虚拟机统计信息监视工具	 用于监视虚拟机各种运行状态信息的命令行工具。 
- jinfo：Java配置信息工具 	实时地查看和调整虚拟机各项参数。 使用jps命令的-v参数可以查看虚拟机启动时显式指定的参数列表
- jmap：Java内存映像工具  生成堆转储快照（一般称为heapdump或dump文件）。 
- jhat：虚拟机堆转储快照分析工具::与jmap搭配使用，来分析jmap生成的堆转储快照。 jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以在浏览器中查看。 
- jstack：Java堆栈跟踪工具:::用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。 线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、 死循环、 请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。 
- JDK的可视化工具:JDK中除了提供大量的命令行工具外，还有两个功能强大的可视化工具：JConsole和VisualVM，


####类文件结构
#####1.概述
Java语言中的各种变量、 关键字和运算符号的语义最终都是由多条字节码命令组合而成
的，因此字节码命令所能提供的语义描述能力肯定会比Java语言本身更加强大。 因此，有一
些Java语言本身无法有效支持的语言特性不代表字节码本身无法有效支持，这也为其他语言
实现一些有别于Java的语言特性提供了基础。
#####2.Class类文件的结构
Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地
排列在Class文件之中，中间没有添加任何分隔符，据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表，

    无符号数属于基本的数据类型，以u1、 u2、 u4、 u8来分别代表1个字节、 2个字节、 4个字节和8个字节的无符号数，无符号数可以用来描述数字、 索引引用、 数量值或者按照UTF-8编码构成字符串值。

    表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。 表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表，

- 魔数与Class文件的版本:每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。  Class文件的魔数的获得很有“浪漫气息”，值为：0xCAFEBABE（咖啡宝贝？）紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（MinorVersion），第7和第8个字节是主版本号（Major Version）。

- 常量池:紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。

- 访问标志：