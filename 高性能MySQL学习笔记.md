##高性能MySQL学习笔记


####并发控制：
- MySQL在两个层面上对并发做了控制：服务器层和存储引擎层
- 读锁（共享锁）和写锁（排他锁）
- MySQL特有的多存储引擎允许控制锁策略和锁粒度，锁策略又分为行级锁和表级锁
- 表级锁：最基本的锁策略和最小开销的锁，锁整表，有写锁时，所有读写操作堵塞，只有在没有写锁时，其他用户能获得读锁，读锁共享。
- 行级锁：最大程度支撑高并发，同时开销最大，行级锁只在存储引擎层实现，在服务器层不实现。

####事务：
具有四大特征：ACID 原子性（Atomicity),一致性（Consistency），隔离性（Isolation），持久性（Durability）

- 原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的操作要么全部执行成功，要不全部回滚，
- 一致性：数据库总是从一个一致的状态转换成另一个一致的状态。
- 隔离性：一个事务所做的修改，在最终提交之前，对其他事务应该是不可见的。
- 持久性：一旦事务提交，则其所做的修改就会永久保存在数据库中。

事务的四中隔离级别：READ UNCOMMITTED(未提交读)，READ COMMITED(提交读)，REPEATABLE READ(可重复读)，SERIALIZABLE(可串行化)

- 未提交读：在这个级别中会产生<font color=red  size=5>**脏读**，</font>即此事务的修改即使没有提交，对其他事务也是可见的，其他事务可读取到未提交的数据。
- 提交读：一个事务开始时，只能看见已提交的事务做出的修改。
- 可重复读：MySQL的默认级别，解决了脏读的问题，在这依旧无法解决<font color=red  size=5>**幻读**</font>的问题，所谓幻读，即在读取某个范围的记录时，另一个事务又在该范围内插入了新的记录，。
- 可串行化：该级别在读取的每一行数据上都加锁，因此会导致大量的超时和锁争用的问题。解决了幻读问题。

死锁：两个或多个事务在同一资源上的相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。为解决这种问题，数据库系统实现了<font color=red  size=5>**各种死锁检测和死锁超时机制**</font> 比如InnoDB存储引擎会检测到死锁的循环依赖，并立即返回一个错误。目前解决方法是<font color=red  size=5>**将持有最少行级的排他锁的事务进行回滚。**</font>

事务日志：使用日志会提交效率。在使用日志时，存储引擎只会将修改行为记录到持久在硬盘上的事务日志上，而不用每次都把数据持久化到磁盘上，事务持久以后，内存中被修改到数据会在后台慢慢刷回到磁盘上。

MySQL提供了两种事务型存储引擎：InnoDB和NDB Cluster，在MySQL中，默认模式是自动提交（AUTOCOMMIT），InnoDB的mvcc使用的方式是添加两个字段，保存时间和删除时间，查询时保证查出来的数据是 保存版本号之前的 和删除时间之后的 。


####性能优化：
性能：完成某件任务所需要的时间度量，性能即响应时间。
优化：在一定的工作负载下尽可能的降低响应时间。