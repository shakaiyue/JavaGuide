##Java设计模式

###<div>java的设计模式大体上分为三大类：</div>
####<p>创建型模式（5种）：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式。</p>
####<p>结构型模式（7种）：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式。</p>
####<p>行为型模式（11种）:策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>

###设计模式遵循的原则有6个：
####1、开闭原则（Open Close Principle）
- 对扩展开放，对修改关闭。

####2、里氏代换原则（Liskov Substitution Principle）
- 只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。

####3、依赖倒转原则（Dependence Inversion Principle）
- 这个是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。

####4、接口隔离原则（Interface Segregation Principle）
- 使用多个隔离的借口来降低耦合度。

####5、迪米特法则（最少知道原则）（Demeter Principle）
- 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

####6、合成复用原则（Composite Reuse Principle）
- 原则是尽量使用合成/聚合的方式，而不是使用继承。继承实际上破坏了类的封装性，超类的方法可能会被子类修改。

#### 1.1:工厂方法模式
- 常用的工厂模式是静态工厂，利用static方法，作为一种类似于常见的工具类Utils等辅助效果，一般情况下工厂类不需要实例化。

#### 1.2:抽象工厂模式（Abstract Factory）
- 一个基础接口定义了功能，每个实现接口的子类就是产品，然后定义一个工厂接口，实现了工厂接口的就是工厂，这时候，接口编程的优点就出现了，我们可以新增产品类（只需要实现产品接口），只需要同时新增一个工厂类，客户端就可以轻松调用新产品的代码。
- 抽象工厂的灵活性就体现在这里，无需改动原有的代码，毕竟对于客户端来说，静态工厂模式在不改动StaticFactory类的代码时无法新增产品，如果采用了抽象工厂模式，就可以轻松的新增拓展类。
####1.3:单例模式（Singleton）
- 在内部创建一个实例，构造器全部设置为private，所有方法均在该实例上改动，在创建上要注意类的实例化只能执行一次，可以采用许多种方法来实现，如Synchronized关键字，或者利用内部类等机制来实现。


##head first 设计模式
###原则
1.找出应用中可变化之处，并将其总结独立出来，与不会变化的代码分开。

2.针对接口编程，而不是针对实现编程。这里的“接口”可以理解为多类型，多态，通常是一个抽象类或接口

3.多用组合，少用继承。

4.为了交互对象之间的松耦合设计而努力。

5.开放关闭原则：类应该对扩展开放，对修改关闭。

6.依赖倒置原则：要依赖抽象类，不要依赖具体类。

7.最少知识原则：减少对象之间的交互。

8.好莱坞原则：别依赖我们，我们会依赖你。

9.单一原则：一个类应该只有一个引起变化的原图。

###设计模式
模式：在某种情境下，针对某问题的某种解决方案。
1.策略模式：定义了算法族，并将其封装起来，让他们之间可以互相替换，算法的变化独立与算法的用户，将行为与对象分隔开。（会飞的鸭子）

2.观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，他的所有依赖者都会收到通知并自动更新。(java.util.Observer,Observerable)（气象观测台）

3.装饰者模式：动态的将责任附加在对象上。若要扩展功能，装饰者提供了比继承者更有弹性的替代方案。（咖啡店装饰咖啡）

4.工厂方法模式：定义了一个创建对象的接口，由子类决定需要实例化的对象，然后封装具体实例化的过程。工厂方法让类实例化推迟到子类。（披萨店）
abstract Product factoryMethod（String type）

5.抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。  
和工厂模式的区别：抽象工厂是通过对象的组合，来创建需要的对象，而工厂模式是通过继承，扩展一个类，并覆盖他的方法（披萨店）

6.单例模式：确保一个类只有一个实例，并且提供一个全局访问点。记得全局访问点要加同步synchronize关键字，或者在静态实例变量是初始化，全局访问点只返回实例变量即可。或使用双重检查锁，只有在实例对象为空是时才开启同步  （巧克力工厂）  
以前的做法：1.私有化一个静态实例变量，2.私有化默认构造器，3.提供一个getInstance方法，加判断若实例为空则返回新建实例，否则直接返回原实例，这样保证永远只有一个实例，且实现了延迟实例化。

7.命令模式：将“请求”封装成对象，以便使用不同的请求，队列，或者日志来参数化其他对象。命令模式也支持可撤销的操作。（遥控器）

8.适配器模式：将一个类的接口，转换为客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。（鸭子和火鸡）

9.外观模式：提供一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

10.模板方法模式：在一个方法中定义了一个算法的骨架，而将这一些步骤延迟到子类中。模板方法使得子类	可以在不改变算法结构的情况下，重新定义算法的某些步骤。模板方法定义为final类型，防止子类修改，方法中调用的是各个步骤方法，可能是抽象方法或者具体方法。（制作咖啡）

11.迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。（不同菜单迭代实现）

12.组合模式：允许你将对象组合成树形结构来表现“整体/部分”层次结构，组合能让客户以一致的方式处理个别对象以及对象组合。	（迭代项中出现子菜单）

13.状态模式：允许对象在内部状态改变时改变他的行为，对象看起来好像修改了他的类（糖果机）

14.代理模式：控制对象访问，为另一个对象提供一个替身或占位符，以控制对这个对象的访问。（远程监控糖果机）
RMI：

15.复合模式：


##sql优化方法
1.不要把SQL语句写得太长，太过冗余；

2.多使用带参数的SQL语句；

3.使用“临时表”暂存中间结果；

4.SQL语句尽量用**大写**， 因为oracle总是先解析SQL语句，把小写的字母转换成大写的再执行。

5.当在SQL语句中连接多个表时, 尽量使用表的别名并把别名前缀于每个列上。这样一来,
就可以减少解析的时间并减少那些由列歧义引起的语法错误。

6.<font color=black  size=>WHERE子句中的连接顺序。 ORACLE采用自下而上的顺序解析WHERE子句,根据这个原理,表之间的连接必须写在其他WHERE条件之前, 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾
</font>

7.SELECT子句中避免使用 * 。 ORACLE在解析的过程中, 会将'*' 依次转换成所有的列名, 这个工作      是通过查询数据字典完成的, 这意味着将耗费更多的时间

8.删除重复记录： 最高效的删除重复记录的方法
``` 
CREATE TABLE TEMP1 SELECT * FROM TEMP    
DELETE FROM TEMP E 
 WHERE E.ROWID > (SELECT MIN(X.ROWID) 
 		  FROM TEMP1 X WHERE X.TEMP_NO = E.TEMP_NO);
```

9.优化GROUP BY：
提高GROUP BY 语句的效率,可以通过将不需要的记录在GROUP BY之前过滤掉。

10.根据需要用UNION ALL替换UNION：
当SQL语句需要UNION两个查询结果集合时,这两个结果集合会以UNION-ALL的方式被合并,
然后在输出最终结果前进行排序。如果用UNION ALL替代UNION, 这样排序就不是必要了。
效率就会因此得到提高。
**UNION去重且排序 UNION ALL不去重不排序 对输出结果排序，在union all可提高效率**

11.用EXISTS替换DISTINCT：**如果查询的两个表大小相当，那么用in和exists差别不大。
如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in：**
例如：表A（小表），表B（大表）1：`select * from A where cc in (select cc from B)`
效率低，用到了A表上cc列的索引；`select * from A where exists(select cc from B where cc=A.cc)`效率高，用到了B表上cc列的索引。相反的2：`select * from B where cc in (select cc from A)`效率高，用到了B表上cc列的索引；`select * from B where exists(select cc from A where cc=B.cc)`
效率低，用到了A表上cc列的索引

12.尽量多使用COMMIT:只要有可能,在程序中尽量多使用COMMIT,这样程序的性能得到提高,需求也会因为COMMIT所释放的资源而减少。

- a. 回滚段上用于恢复数据的信息。 
- b. 被程序语句获得的锁。
- c. redo log buffer 中的空间。 
- d. ORACLE为管理上述3种资源中的内部花销。

13.from 是从右向左执行，因此将记录量少的表放在右边，where是从后往前执行，因此将过滤数据量大的条件放在最后，可以提高效率。

14.用Where子句替换HAVING子句： 
**on、where、having这三个都可以加条件的子句中,on是最先执行,where次之,having最后。**

- on 先把不符合条件的记录过滤后才进行统计，可以减少中间运算要处理的数据，速度最快。
- where where比having快点，因为它过滤数据后才进行sum.


15.用TRUNCATE替代DELETE：
  当删除表中的记录时,在通常情况下, 回滚段(rollback segments)用来存放可以被恢复的
信息。如果你没有COMMIT事务,ORACLE会将数据恢复到删除之前的状态(准确地说是恢复到执
行删除命令之前的状况)。而当运用TRUNCATE时,回滚段不再存放任何可被恢复的信息。当命
令运行后,数据不能被恢复。因此很少的资源被调用,执行时间也会很短。
**DELETE 可回滚恢复，TRUNCATE 不可恢复**

16.用索引提高效率： 

- 单一索引:Create Index <Index-Name> On <Table_Name>(Column_Name);
- 复合索引: Create Index i_deptno_job on emp(deptno,job); —>在emp表的deptno、job列建立索引。
　　select * from emp where deptno=66 and job='sals' ->走索引。
　　select * from emp where deptno=66 OR job='sals' ->将进行全表扫描。不走索引
　　select * from emp where deptno=66 ->走索引。
　　select * from emp where job='sals' ->进行全表扫描、不走索引。

　　如果在where 子句中有OR 操作符或单独引用Job 列(索引列的后面列) 则将不会走索引，将会进行全表扫描。

- 建设原则:
1.索引应该经常建在Where 子句经常用到的列上。如果某个大表经常使用某个字段进行查询，并且检索行数小于总表行数的5%。则应该考虑。
2、对于两表连接的字段，应该建立索引。如果经常在某表的一个字段进行Order By 则也经过进行索引。
3、不应该在小表上建设索引。

- 优缺点:
　1、索引主要进行提高数据的查询速度。 当进行DML时，会更新索引。因此索引越多，则DML越慢，其需要维护索引。 因此在创建索引及DML需要权衡。
- 注意事项：索引列上不要用函数；索引列上不要使用NOT(!=、<>)改用(< or >)；避免在索引列上使用NOT：NOT会产生在和在索引列上使用函数相同的影响。当ORACLE遇到NOT,就会停止使用索引转
而执行全表扫描。;避免在索引列上使用IS NOT NULL 或者IS NULL ;避免改变索引列的类型: 


###GC
自适应垃圾回收机制：若所有对象稳定，gc效率低时会切换到“标记-清扫”方式，若堆空间出现很多碎片，则会切换回“停止-复制”方式。

标记-清扫： 遍历引用，每找到一个存活对象，会给对象一个标记，遍历完之后会清除没有标记的对象

停止-复制： 先暂停运行，将存活对象复制到新堆中，此时是相挨的因为保持紧凑，可以直接分配新空间